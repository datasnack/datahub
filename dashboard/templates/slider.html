{% extends "base.html" %}
{% load humanize %}
{% load static %}

{% block content %}
	<link rel="stylesheet" type="text/css" href="{% static 'slider.css' %}">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/RubaXa/Sortable/Sortable.min.js"></script>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">


    <h1>Temporal Slider</h1>

    <div class="mt-3">
		<label for="type-dropdown" class="form-label fw-bold">Select Shape Type:</label>
		<select id="type-dropdown" class="form-select">
			<option value="">Select Type</option>
			{% for type in types %}
				<option value="{{ type.id }}">{{ type }}</option>
			{% endfor %}
		</select>
	</div>

	<div class="border rounded p-3 m-4" style="max-height: 250px; overflow-y: auto;">
		<div class="row">
			<div class="col border-end">
				<label class="form-label fw-bold">Available Data Layers:</label>
				<div id="available-datalayers">
					{% for datalayer in datalayers %}
						<div class="datalayer-item">
							<button class="btn btn-sm btn-outline-success add-datalayer m-1" data-datalayer="{{ datalayer.key }}">
								<i class="bi bi-plus"></i> {{ datalayer.name }}
							</button>
						</div>
					{% endfor %}
				</div>
			</div>
			<div class="col-7">
				<label class="form-label fw-bold">Selected Data Layers:</label>
				<div id="selected-datalayers">
				</div>
			</div>
		</div>
	</div>

    <div id="map" style="height: 600px; width: 100%; margin-top: 20px;">
		<div id="loading-message">Loading, please wait...</div>
	</div>

    <div id="year-slider" style="margin: 50px;"></div>
    <span id="year-slider-value"></span>

	<div id="graph" style="width: 100%; height: 400px;"></div>


    <script>
		let map;
		let layerGroups = {};

		$(document).ready(function() {
			$('#type-dropdown').prop('selectedIndex', 0);
			$('#loading-message').hide();
			if (!map) {
				map = L.map('map').setView(
					[parseFloat("{{ datahub_center_y }}"), parseFloat("{{ datahub_center_x }}")],
					parseInt("{{ datahub_center_zoom }}")
				);

				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
				}).addTo(map);
			}

		});

		$('.add-datalayer').on('click', function () {
			const shapeType = $('#type-dropdown').val();
			if (shapeType) {
				let datalayerKey = $(this).data('datalayer');
				let datalayerName = $(this).text();

				let selectedItem = `
						<div class="datalayer-item border rounded m-2 p-2" id="selected-${datalayerKey}">
							<h6> ${datalayerName} </h6>
							<div class="datalayer-item-util d-none" id="selected-${datalayerKey}-util">
							</div>
						</div>
					`;
				$('#selected-datalayers').append(selectedItem);
				$(this).prop('disabled', true);
				processObjects(datalayerKey)
			} else {
				alert("Please select the type!");
			}
		});



		function processObjects(dataLayerKey) {
			$.ajax({
				url: "{% url 'get_datalayer_available_years' %}",
				data: {'data_layer_key': dataLayerKey},
				success: function (data) {
					const slider = $('#year-slider')[0];
					if (slider && slider.noUiSlider) {
						updateSlider(slider, data)
					} else {
						initializeSlider(slider, data)
					}
					createNewLayer(slider, dataLayerKey);
					{#initializeGraph();#}
				}
			});
		}

		function initializeSlider(slider, availableYears) {
			const minYear = Math.min(...availableYears);
			const maxYear = Math.max(...availableYears);
			noUiSlider.create(slider, {
				start: minYear,
				step: 1,
				range: {
					'min': minYear,
					'max': maxYear
				},
				tooltips: {
					to: function(value) {
						return value.toFixed(0);
					},
					from: function(value) {
						return Number(value);
					}
				},
				pips: {
					mode: 'values',
					values: [minYear, maxYear],
					density: 10
				}
			});
			slider.noUiSlider.on('change', updateMap);
		}

		function updateSlider(slider, availableYears) {
			const range = slider.noUiSlider.options.range;
			const newMinYear = Math.min(range.min, Math.min(...availableYears))
			const newMaxYear = Math.max(range.max, Math.max(...availableYears))
			slider.noUiSlider.updateOptions({
				range: {
					'min': newMinYear,
					'max': newMaxYear
				}
			});
		}

		function createNewLayer(slider, dataLayerKey) {
			$('#loading-message').show();
			const shapeType = $('#type-dropdown').val();
			const selectedYear = parseInt(slider.noUiSlider.get());

			let minValue = 0;
			let maxValue = 0;

			$.ajax({
				url: "{% url 'get_min_max_dl_value' %}",
				data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType},
				success: function(data) {
					minValue = data.min_value;
					maxValue = data.max_value;
				},
				error: function(error) {
					console.error('Error finding min and max values of datalayer:', error);
				}
			});

			$.ajax({
				url: "{% url 'get_dl_value_for_year_shapes' %}",
				data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType, 'year': selectedYear},
				success: function(data) {
					const newLayerGroup = L.layerGroup();
					layerGroups[dataLayerKey] = newLayerGroup;

					const names = data.names;
					const geometries = data.geometries;
					const dlValues = data.dl_values;

					for (const shapeId in geometries) {
						const value = dlValues[shapeId];
						const name = names[shapeId] || 'Unknown';

						let geometry;
						if (typeof geometries[shapeId] === 'string') {
							geometry = JSON.parse(geometries[shapeId]);
						} else {
							geometry = geometries[shapeId];
						}

						const color = getColor(value, minValue, maxValue);

						const geoJsonFeature = {
							type: 'Feature',
							geometry: geometry,
							properties: { id: shapeId, name, value }
						};

						const geoJsonLayer = L.geoJSON(geoJsonFeature, {
							style: () => ({
								fillColor: color,
								weight: 2,
								opacity: 1,
								color: 'black',
								fillOpacity: 0.9
							}),
							{#onEachFeature: (feature, layer) => {#}
							{#	layer.bindPopup(`<b>${feature.properties.name}</b><br>Value: <br>${feature.properties.value}`);#}
							{#	layer.on('click', function () {#}
							{#		addToGraph(feature.properties.id);#}
							{#	});#}
							{##}
						});
						geoJsonLayer.addTo(newLayerGroup);
					}
					newLayerGroup.addTo(map);
					{#updateLegend(minValue, maxValue);#}
					$('#loading-message').hide();
				},
				error: function (xhr, status, error) {
					console.error('Error updating map:', error);
					$('#loading-message').hide();
				}
			});
		}

		function updateMap() {
			$('#loading-message').show();
			const shapeType = $('#type-dropdown').val();
			const selectedYear = parseInt($('#year-slider')[0].noUiSlider.get());

			let minValue = 0;
			let maxValue = 0;

			Object.entries(layerGroups).forEach(([dataLayerKey, layerGroup]) => {
    			console.log(`Key: ${dataLayerKey}, LayerGroup:`, layerGroup);
				$.ajax({
					url: "{% url 'get_min_max_dl_value' %}",
					data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType},
					success: function(data) {
						minValue = data.min_value;
						maxValue = data.max_value;
					},
					error: function(error) {
						console.error('Error finding min and max values of datalayer:', error);
					}
				});
				$.ajax({
					url: "{% url 'get_dl_value_for_year_shapes' %}",
					data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType, 'year': selectedYear},
					success: function(data) {
						const existingLayerGroup = layerGroups[dataLayerKey];
            			existingLayerGroup.clearLayers();

						const names = data.names;
						const geometries = data.geometries;
						const dlValues = data.dl_values;

						for (const shapeId in geometries) {
							const value = dlValues[shapeId];
							const name = names[shapeId] || 'Unknown';

							let geometry;
							if (typeof geometries[shapeId] === 'string') {
								geometry = JSON.parse(geometries[shapeId]);
							} else {
								geometry = geometries[shapeId];
							}

							const color = getColor(value, minValue, maxValue);

							const geoJsonFeature = {
								type: 'Feature',
								geometry: geometry,
								properties: { id: shapeId, name, value }
							};

							const geoJsonLayer = L.geoJSON(geoJsonFeature, {
								style: () => ({
									fillColor: color,
									weight: 2,
									opacity: 1,
									color: 'black',
									fillOpacity: 0.9
								}),
								{#onEachFeature: (feature, layer) => {#}
								{#	layer.bindPopup(`<b>${feature.properties.name}</b><br>Value: <br>${feature.properties.value}`);#}
								{#	layer.on('click', function () {#}
								{#		addToGraph(feature.properties.id);#}
								{#	});#}
								{##}
							});
							geoJsonLayer.addTo(existingLayerGroup);
						}
						{#updateLegend(minValue, maxValue);#}
						$('#loading-message').hide();
					},
					error: function (xhr, status, error) {
						console.error('Error updating map:', error);
						$('#loading-message').hide();
					}
				});
			})
		}

		{#function initializeGraph(){#}
		{#	const dataLayer = $('#data-layer-dropdown').val();#}
		{#	const dataLayerName = $('#data-layer-dropdown option:selected').text();#}
		{#	let traces = [];#}
		{#	$.ajax({#}
		{#		url: "{% url 'get_historical_data_highest_type' %}",#}
		{#		data: {'data_layer_key': dataLayer},#}
		{#		success: function(data) {#}
		{#			let historicalData = data.historical_data;#}
		{#			let highestShapeName = data.highest_shape_name;#}
		{#			if (historicalData.length > 0) {#}
		{#				traces.push({#}
		{#					x: historicalData.map(d => d.year),#}
		{#					y: historicalData.map(d => d.value),#}
		{#					mode: 'lines+markers',#}
		{#					showlegend: true,#}
		{#					name: highestShapeName,#}
		{#					line: {color: '#8979da'}#}
		{#				});#}
		{#				let layout = {#}
		{#					title: dataLayerName,#}
		{#					xaxis: { title: 'Year' },#}
		{#					yaxis: { title: 'Value' },#}
		{#					width: null,#}
		{#					height: 400#}
		{#				};#}
		{#				Plotly.newPlot('graph', traces, layout);#}
		{#			}#}
		{#		},#}
		{#		error: function (xhr, status, error) {#}
		{#			console.error('Error initializing graph:', error);#}
		{#		}#}
		{#	})#}
		{##}
		{##}
		{##}
		{#function addToGraph(shapeId) {#}
		{#	const datalayer = $('#data-layer-dropdown').val();#}
		{#	$.ajax({#}
		{#		url: "{% url 'get_historical_data_shape' %}",#}
		{#		data: {'data_layer_key': datalayer, 'shape_id': shapeId},#}
		{#		success: function(data) {#}
		{#			const historicalData = data.historical_data;#}
		{#			const shapeName = data.shape_name#}
		{#			if (historicalData.length > 0) {#}
		{#				const newTrace = {#}
		{#					x: historicalData.map(d => d.year),#}
		{#					y: historicalData.map(d => d.value),#}
		{#					mode: 'lines+markers',#}
		{#					showlegend: true,#}
		{#					name: shapeName#}
		{#				};#}
		{##}
		{#				Plotly.addTraces('graph', newTrace);#}
		{#			}#}
		{##}
		{#		},#}
		{#		error: function (xhr, status, error) {#}
		{#			console.error('Error adding to graph:', error);#}
		{#		}#}
		{#	});#}
		{##}
		{##}

		function updateLegend(minValue, maxValue) {
			document.getElementById('min-label').textContent = Math.round(minValue);
			document.getElementById('max-label').textContent = Math.round(maxValue);
		}

		function getColor(value, minValue, maxValue) {
            const norm_val = (value - minValue) / (maxValue - minValue);
			if (norm_val > 0.9) return '#3d85c6';
            if (norm_val > 0.8) return '#5091cb';
			if (norm_val > 0.7) return '#639dd1';
            if (norm_val > 0.6) return '#77a9d7';
			if (norm_val > 0.5) return '#8ab5dc';
            if (norm_val > 0.4) return '#9ec2e2';
			if (norm_val > 0.3) return '#b1cee8';
            if (norm_val > 0.2) return '#c4daed';
			if (norm_val > 0.1) return '#d8e6f3';
            return '#ebf2f9';
        }

    </script>
{% endblock %}
