{% extends "base.html" %}
{% load humanize %}
{% load static %}

{% block content %}
	<link rel="stylesheet" type="text/css" href="{% static 'slider.css' %}">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/RubaXa/Sortable/Sortable.min.js"></script>

	<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">


    <h1>Temporal Slider</h1>

    <div class="mt-3">
		<label for="type-dropdown" class="form-label fw-bold">Select Shape Type:</label>
		<select id="type-dropdown" class="form-select">
			<option value="">Select Type</option>
			{% for type in types %}
				<option value="{{ type.id }}">{{ type }}</option>
			{% endfor %}
		</select>
	</div>

	<div class="border rounded p-3 m-4" style="max-height: 250px; overflow-y: auto;">
		<div class="row">
			<div class="col border-end">
				<label class="form-label fw-bold">Available Data Layers:</label>
				<div id="available-datalayers" style="max-height: 250px; overflow-y: auto;">
					{% for datalayer in datalayers %}
						<div class="datalayer-item">
							<button class="btn btn-sm btn-outline-success add-datalayer m-1" data-datalayer="{{ datalayer.key }}">
								<i class="bi bi-plus"></i> {{ datalayer.name }}
							</button>
						</div>
					{% endfor %}
				</div>
			</div>
			<div class="col-7">
				<label class="form-label fw-bold">Selected Data Layers:</label>
				<div id="selected-datalayers" style="max-height: 250px; overflow-y: auto;">
				</div>
			</div>
		</div>
	</div>

    <div id="map" style="height: 600px; width: 100%; margin-top: 20px;">
		<div id="loading-message">Loading, please wait...</div>
	</div>

    <div id="year-slider" style="margin: 50px;"></div>
    <span id="year-slider-value"></span>

	<div id="graph" style="width: 100%; height: 400px;"></div>


    <script>
		let map;
		let layerGroups = {};

		$(document).ready(function() {
			$('#type-dropdown').prop('selectedIndex', 0);
			$('#loading-message').hide();
			if (!map) {
				map = L.map('map').setView(
					[parseFloat("{{ datahub_center_y }}"), parseFloat("{{ datahub_center_x }}")],
					parseInt("{{ datahub_center_zoom }}")
				);

				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
				}).addTo(map);
			}

		});

		$('.add-datalayer').on('click', function () {
			const shapeType = $('#type-dropdown').val();
			if (shapeType) {
				let datalayerKey = $(this).data('datalayer');
				let datalayerName = $(this).text();

				let selectedItem = `
					<div class="datalayer-item border rounded m-2 p-2" id="selected-${datalayerKey}">
						<label class="col-form-label-sm" data-bs-toggle="collapse" data-bs-target="#selected-${datalayerKey}-util" style="cursor: pointer;">
							${datalayerName}
						</label>
						<div class="collapse" id="selected-${datalayerKey}-util">
						</div>
					</div>
				`;
				$('#selected-datalayers').append(selectedItem);
				$(this).prop('disabled', true);
				processObjects(datalayerKey)
			} else {
				alert("Please select the type!");
			}
		});


		function processObjects(dataLayerKey) {
			$.ajax({
				url: "{% url 'get_datalayer_available_years' %}",
				data: {'data_layer_key': dataLayerKey},
				success: function (data) {
					const slider = $('#year-slider')[0];
					if (slider && slider.noUiSlider) {
						updateSlider(slider, data)
					} else {
						initializeSlider(slider, data)
					}
					createNewLayer(slider, dataLayerKey);
					{#initializeGraph();#}
				}
			});
		}

		function initializeSlider(slider, availableYears) {
			const minYear = Math.min(...availableYears);
			const maxYear = Math.max(...availableYears);
			noUiSlider.create(slider, {
				start: minYear,
				step: 1,
				range: {
					'min': minYear,
					'max': maxYear
				},
				tooltips: {
					to: function(value) {
						return value.toFixed(0);
					},
					from: function(value) {
						return Number(value);
					}
				},
				pips: {
					mode: 'values',
					values: [minYear, maxYear],
					density: 10
				}
			});
			slider.noUiSlider.on('change', updateMap);
		}

		function updateSlider(slider, availableYears) {
			const range = slider.noUiSlider.options.range;
			const newMinYear = Math.min(range.min, Math.min(...availableYears))
			const newMaxYear = Math.max(range.max, Math.max(...availableYears))
			slider.noUiSlider.updateOptions({
				range: {
					'min': newMinYear,
					'max': newMaxYear
				}
			});
		}

		async function fetchMinMaxValues(dataLayerKey, shapeType) {
			try {
				return await $.ajax({
					url: "{% url 'get_min_max_dl_value' %}",
					data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType}
				});
			} catch (error) {
				console.error(`Error fetching min/max for ${dataLayerKey}:`, error);
				throw error;
			}
		}

		async function fetchLayerData(dataLayerKey, shapeType, selectedYear) {
			try {
				return await $.ajax({
					url: "{% url 'get_dl_value_for_year_shapes' %}",
					data: {'data_layer_key': dataLayerKey, 'shape_type': shapeType, 'year': selectedYear}
				});
			} catch (error) {
				console.error(`Error fetching layer data for ${dataLayerKey}:`, error);
				throw error;
			}
		}

		function createLayerGroup(dataLayerKey, minValue, maxValue, data, presetColors) {
			const { names, geometries, dl_values: dlValues } = data;
			const layerGroup = L.layerGroup();

			Object.entries(geometries).forEach(([shapeId, geometryData]) => {
				const value = dlValues[shapeId];
				const name = names[shapeId] || 'Unknown';
				const geometry = typeof geometryData === 'string' ? JSON.parse(geometryData) : geometryData;

				const color = getColor(value, minValue, maxValue, presetColors);

				const geoJsonFeature = {
					type: 'Feature',
					geometry: geometry,
					properties: { id: shapeId, name, value }
				};

				const geoJsonLayer = L.geoJSON(geoJsonFeature, {
					style: () => ({
						fillColor: color,
						weight: 2,
						opacity: 1,
						color: 'black',
						fillOpacity: 0.9
					}),
					onEachFeature: (feature, layer) => {
						layer.bindPopup(`<b>${feature.properties.name}</b><br>Value: <br>${feature.properties.value}`);
					}
				});

				geoJsonLayer.addTo(layerGroup);
			});

			return layerGroup;
		}

		async function updateOrCreateLayer(dataLayerKey, shapeType, selectedYear, layerGroup, presetColors) {
			try {
				const minMaxData = await fetchMinMaxValues(dataLayerKey, shapeType);
				const { min_value: minValue, max_value: maxValue } = minMaxData;

				const layerData = await fetchLayerData(dataLayerKey, shapeType, selectedYear);

				updateLegend(dataLayerKey, minValue, maxValue, presetColors)

				if (layerGroup) {
					layerGroup.clearLayers();
					createLayerGroup(dataLayerKey, minValue, maxValue, layerData, presetColors).eachLayer(layer => layer.addTo(layerGroup));
					applyPreset(dataLayerKey, presetColors)
				} else {
					const newLayerGroup = createLayerGroup(dataLayerKey, minValue, maxValue, layerData, presetColors);
					layerGroups[dataLayerKey] = newLayerGroup;
					newLayerGroup.addTo(map);
				}
			} catch (error) {
				console.error(`Error processing layer ${dataLayerKey}:`, error);
			} finally {
				$('#loading-message').hide();
			}
		}

		async function updateMap() {
			$('#loading-message').show();
			const shapeType = $('#type-dropdown').val();
			const selectedYear = parseInt($('#year-slider')[0].noUiSlider.get());

			for (const [dataLayerKey, layerGroup] of Object.entries(layerGroups)) {
				const selectedPreset = $(`#preset-select-${dataLayerKey}`).val();
				const presetColors = presets[selectedPreset].colors;
				await updateOrCreateLayer(dataLayerKey, shapeType, selectedYear, layerGroup, presetColors);
			}

			$('#loading-message').hide();
		}

		async function createNewLayer(slider, dataLayerKey) {
			$('#loading-message').show();
			const shapeType = $('#type-dropdown').val();
			const selectedYear = parseInt(slider.noUiSlider.get());

			let newUtilItems = `
				<div class="d-flex align-items-stretch border rounded m-2 p-2" id="legend-items-${dataLayerKey}">
					<div id="legend-description-${dataLayerKey}" class="d-flex align-items-stretch">
						<div class="d-flex flex-column justify-content-between" id="legend-labels-column-${dataLayerKey}">
							<label class="col-form-label-sm" id="min-label-${dataLayerKey}">Min</label>
							<label class="col-form-label-sm" id="max-label-${dataLayerKey}">Max</label>
						</div>
						<div class="p-2 flex-grow-1" id="legend-bar-${dataLayerKey}"></div>
					</div>
					<div class="legend-customize-${dataLayerKey} mx-4 d-flex align-items-sm-center">
						<div>
							<label for="preset-select-${dataLayerKey}" class="col-form-label-sm">Adjust Preset:</label>
							<select id="preset-select-${dataLayerKey}" class="form-control">
							</select>
							<label for="transparency-input-${dataLayerKey}" class="col-form-label-sm">Adjust Transparency (0-1):</label>
							<input class="form-control" id="transparency-input-${dataLayerKey}">
						</div>
					</div>
					<div id="util-buttons-${dataLayerKey}" class="mx-4 d-flex flex-column align-items-sm-center justify-content-center">
						<button id="apply-customization-${dataLayerKey}-btn" class="btn btn-primary btn-sm m-4 apply-customization">Apply Customization</button>
						<button id="remove-${dataLayerKey}-btn" class="btn btn-danger btn-sm remove-datalayer">Remove Layer</button>
					</div>
				</div>`;

			$(`#selected-${dataLayerKey}-util`).append(newUtilItems);
			$(`#selected-${dataLayerKey}-util`).removeClass("d-none");

			populateLegendSelect(dataLayerKey)
			const defaultPresetColors = presets[Object.keys(presets)[0]].colors;

			await updateOrCreateLayer(dataLayerKey, shapeType, selectedYear, null, defaultPresetColors);

			$('#loading-message').hide();
		}

		$(document).on('click', '.apply-customization', function () {
			let buttonId = $(this).attr('id');
			let dataLayerKey = buttonId.match(/apply-customization-(\S+)-btn/)[1];
			const selectedPreset = $(`#preset-select-${dataLayerKey}`).val();
			if (presets[selectedPreset]) {
				const presetColors = presets[selectedPreset].colors;
				applyPreset(dataLayerKey, presetColors);
			} else {
				alert('Invalid preset selected.');
			}
		});

		$(document).on('click', '.remove-datalayer', function () {
			let buttonId = $(this).attr('id');
			let dataLayerKey = buttonId.match(/remove-(\S+)-btn/)[1];
			removeLayer(dataLayerKey)
		});

		const presets = {{ presets|safe }};
		let currentPreset = presets[Object.keys(presets)[0]].colors;

		function populateLegendSelect(dataLayerKey) {
			const presetSelect = $(`#preset-select-${dataLayerKey}`);
			Object.keys(presets).forEach(presetKey => {
				const option = $('<option>')
					.attr('value', presetKey)
					.text(presets[presetKey].name);
				presetSelect.append(option);
			});
		}

		function updateLegend(dataLayerKey, minValue, maxValue, presetColors) {
			$(`#min-label-${dataLayerKey}`).text(Math.round(minValue));
			$(`#max-label-${dataLayerKey}`).text(Math.round(maxValue));
			updateLegendBar(dataLayerKey, presetColors)
		}

		function updateLegendBar(dataLayerKey, presetColors) {
			const legendBar = $(`#legend-bar-${dataLayerKey}`);
			legendBar.empty();
			const column = $('<div>').addClass('d-flex w-100 h-100 flex-column');
			presetColors.forEach(color => {
				const row = $('<div>')
					.addClass('flex-fill')
					.css({
						background: color,
						width: '10px',
						height: '20px'
					});
				column.append(row);
			});
			legendBar.append(column);
		}

		function applyPreset(dataLayerKey, presetColors) {
			updateLegendBar(dataLayerKey, presetColors)
			let transparencyInput = $(`#transparency-input-${dataLayerKey}`).val();
			const transparency = transparencyInput ? parseFloat(transparencyInput) : 1;
			let layerGroup = layerGroups[dataLayerKey]
			const minValue = parseInt($(`#min-label-${dataLayerKey}`).text())
			const maxValue = parseInt($(`#max-label-${dataLayerKey}`).text())
			layerGroup.eachLayer(layer => {
				if (layer._layers) {
					Object.values(layer._layers).forEach(subLayer => {
						if (subLayer.feature && subLayer.feature.properties) {
							const value = subLayer.feature.properties.value;
							const color = getColor(value, minValue, maxValue, presetColors);
							subLayer.setStyle({
								fillColor: color,
								fillOpacity: transparency,
							});
						} else {
							console.warn('Sub-layer lacks feature or properties:', subLayer);
						}
					});
				}
			});
		}

		function removeLayer(dataLayerKey) {

		}

		function getColor(value, minValue, maxValue, presetColors) {
			const norm_val = (value - minValue) / (maxValue - minValue);
			if (norm_val > 0.8) return presetColors[4];
			if (norm_val > 0.6) return presetColors[3];
			if (norm_val > 0.4) return presetColors[2];
			if (norm_val > 0.2) return presetColors[1];
			return presetColors[0];
		}

		{#function initializeGraph(){#}
		{#	const dataLayer = $('#data-layer-dropdown').val();#}
		{#	const dataLayerName = $('#data-layer-dropdown option:selected').text();#}
		{#	let traces = [];#}
		{#	$.ajax({#}
		{#		url: "{% url 'get_historical_data_highest_type' %}",#}
		{#		data: {'data_layer_key': dataLayer},#}
		{#		success: function(data) {#}
		{#			let historicalData = data.historical_data;#}
		{#			let highestShapeName = data.highest_shape_name;#}
		{#			if (historicalData.length > 0) {#}
		{#				traces.push({#}
		{#					x: historicalData.map(d => d.year),#}
		{#					y: historicalData.map(d => d.value),#}
		{#					mode: 'lines+markers',#}
		{#					showlegend: true,#}
		{#					name: highestShapeName,#}
		{#					line: {color: '#8979da'}#}
		{#				});#}
		{#				let layout = {#}
		{#					title: dataLayerName,#}
		{#					xaxis: { title: 'Year' },#}
		{#					yaxis: { title: 'Value' },#}
		{#					width: null,#}
		{#					height: 400#}
		{#				};#}
		{#				Plotly.newPlot('graph', traces, layout);#}
		{#			}#}
		{#		},#}
		{#		error: function (xhr, status, error) {#}
		{#			console.error('Error initializing graph:', error);#}
		{#		}#}
		{#	})#}
		{##}
		{##}
		{##}
		{#function addToGraph(shapeId) {#}
		{#	const datalayer = $('#data-layer-dropdown').val();#}
		{#	$.ajax({#}
		{#		url: "{% url 'get_historical_data_shape' %}",#}
		{#		data: {'data_layer_key': datalayer, 'shape_id': shapeId},#}
		{#		success: function(data) {#}
		{#			const historicalData = data.historical_data;#}
		{#			const shapeName = data.shape_name#}
		{#			if (historicalData.length > 0) {#}
		{#				const newTrace = {#}
		{#					x: historicalData.map(d => d.year),#}
		{#					y: historicalData.map(d => d.value),#}
		{#					mode: 'lines+markers',#}
		{#					showlegend: true,#}
		{#					name: shapeName#}
		{#				};#}
		{##}
		{#				Plotly.addTraces('graph', newTrace);#}
		{#			}#}
		{##}
		{#		},#}
		{#		error: function (xhr, status, error) {#}
		{#			console.error('Error adding to graph:', error);#}
		{#		}#}
		{#	});#}
		{##}
		{##}

    </script>
{% endblock %}
